// Copyright 2021 Board of Trustees of the University of Illinois
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/rokwire/rokwire-sdk-go/utils/errors"
	"github.com/rokwire/rokwire-sdk-go/utils/logging/logs"
	"github.com/rokwire/rokwire-sdk-go/utils/logging/logutils"
)

type handlerFunc = func(*logs.Log, *http.Request) logs.HTTPResponse

// WebAdapter is the web adapter that serves APIs
type WebAdapter struct {
	logger *logs.Logger
}

// Start serves API content on the WebAdapter
func (we WebAdapter) Start() {
	// Empty permissions indicates that no permissions are required
	http.HandleFunc("/test", we.wrapFunc(we.test))

	http.ListenAndServe(":5000", nil)
}

// test endpoint tests logging
func (we WebAdapter) test(l *logs.Log, req *http.Request) logs.HTTPResponse {
	param := req.URL.Query().Get("param")
	l.AddContext("param", param)

	err := checkParam(param)
	if err != nil {
		return l.HTTPResponseError(logutils.MessageActionError(logutils.ActionValidate, logutils.TypeQueryParam, nil), err, http.StatusBadRequest, true)
	}

	l.Info("Success")

	return l.HTTPResponseSuccess()
}

func checkParam(param string) error {
	if param == "test" {
		return nil
	}

	return errors.WrapErrorData(logutils.StatusInvalid, logutils.TypeArg, &logutils.FieldArgs{"param": param}, errors.New("{\"error\": \"invalid parmeter\"}")).SetStatus("bad-param")
}

// wrapFunc provides a standard wrapper that performs request logsging
func (we WebAdapter) wrapFunc(handler handlerFunc) http.HandlerFunc {
	// Receive request with tokens generated by auth service
	return func(w http.ResponseWriter, req *http.Request) {
		logsObj := we.logger.NewRequestLog(req)

		logsObj.RequestReceived()
		response := handler(logsObj, req)
		logsObj.SendHTTPResponse(w, response)
		logsObj.RequestComplete()
	}
}

// NewWebAdapter creates new WebAdapter instance
func NewWebAdapter(logger *logs.Logger) WebAdapter {
	return WebAdapter{logger: logger}
}

func main() {
	// Suppress standard health checker logs
	loggerOpts := logs.LoggerOpts{SuppressRequests: logs.NewStandardHealthCheckHTTPRequestProperties("/test")}

	// Instantiate a logger
	var logger = logs.NewLogger("example", &loggerOpts)
	logger.SetLevel(logs.Debug)

	var random = 1234
	logger.Infof("Starting service: %d", random)
	logger.InfoWithFields("ENV_VAR", logutils.Fields{"name": "test", "val": 123})

	go callTest()

	// Instantiate and start a new WebAdapter
	adapter := NewWebAdapter(logger)
	adapter.Start()
}

func callTest() (*http.Response, error) {
	time.Sleep(2 * time.Second)

	req, err := http.NewRequest("GET", "http://127.0.0.1:5000/test", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "example_token")
	req.Header.Set("Header", "test")
	req.Header.Set("span-id", "4313")

	q := req.URL.Query()
	q.Add("param", "test2")
	req.URL.RawQuery = q.Encode()

	fmt.Println(req.URL.String())

	client := &http.Client{}

	response, err := client.Do(req)
	if err != nil {
		fmt.Printf("Error: %v", err)
	} else {
		bodyBytes, err := ioutil.ReadAll(response.Body)
		if err != nil {
			fmt.Printf("Error Reading Body: %v", err)
		} else {
			bodyString := string(bodyBytes)
			fmt.Printf("Response: %v - Body: %s", response, bodyString)
		}
	}
	return response, err
}
